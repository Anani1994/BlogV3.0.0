(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{325:function(t,a,n){"use strict";n.r(a);var i=n(482),e=n(411);for(var r in e)"default"!==r&&function(t){n.d(a,t,function(){return e[t]})}(r);var s=n(0),l=Object(s.a)(e.default,i.a,i.b,!1,null,null,null);l.options.__file="src/views/articles/frontend/JS/factorial.vue",a.default=l.exports},410:function(t,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0}),a.default={data:function(){return{toTop:this.$util.toTop}}}},411:function(t,a,n){"use strict";n.r(a);var i=n(410),e=n.n(i);for(var r in i)"default"!==r&&function(t){n.d(a,t,function(){return i[t]})}(r);a.default=e.a},482:function(t,a,n){"use strict";var i=function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("BoWen",[n("div",{staticClass:"p-1",attrs:{slot:"catalog"},slot:"catalog"},[n("Steps",{attrs:{direction:"vertical"}},[n("Step",{attrs:{title:"经典递归",content:"经典的递归函数",status:"wait"},nativeOn:{click:function(a){t.toTop("#factorial-0",30)}}}),t._v(" "),n("Step",{attrs:{title:"经典递归的弊端",content:"经典的递归函数的弊端",status:"wait"},nativeOn:{click:function(a){t.toTop("#factorial-1",30)}}}),t._v(" "),n("Step",{attrs:{title:"更好的递归",content:"解决经典的递归函数的弊端",status:"wait"},nativeOn:{click:function(a){t.toTop("#factorial-2",30)}}})],1)],1),t._v(" "),n("div",{staticClass:"px-1"},[n("div",{staticClass:"py-3 text-center"},[n("h1",[n("Icon",{attrs:{type:"ios-book-outline"}}),t._v(" 递归函数")],1),t._v(" "),n("p",{staticClass:"pt-1"},[t._v("递归函数是在一个函数通过名字调用自身")])]),t._v(" "),n("h3",{staticClass:"ml-1",attrs:{id:"factorial-0"}},[n("Icon",{attrs:{type:"logo-buffer"}}),t._v(" 经典递归")],1),t._v(" "),n("Divider"),t._v(" "),n("p",[t._v("递归函数是一个函数通过名字调用自身，下面的函数是一个经典的递归函数：")]),t._v(" "),n("pre",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"ml-2"},[n("code",{staticClass:"js"},[t._v("function factorial (num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * factorial(num-1);\n    }\n} ")])]),t._v(" "),n("h3",{staticClass:"ml-1",attrs:{id:"factorial-1"}},[n("Icon",{attrs:{type:"logo-buffer"}}),t._v(" 经典递归的弊端")],1),t._v(" "),n("Divider"),t._v(" "),n("p",[t._v("经典的递归函数存在一个弊端，就像下面这样：")]),t._v(" "),n("pre",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"ml-2"},[n("code",{staticClass:"js"},[t._v("function factorial (num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * factorial(num-1);\n    }\n}\nvar anotherFactorial = factorial;\nfactorial = null;\nconsole.log(anotherFactorial(4)); // 报错")])]),t._v(" "),n("p",[t._v("上面由于在 factorial() 函数内部通过函数名调用了自身，所以当我们将 factorial 设为 null，执行 anotherFactorial(4) 时，由于 factorial 已经不是函数，所以报错。")]),t._v(" "),n("h3",{staticClass:"ml-1",attrs:{id:"factorial-2"}},[n("Icon",{attrs:{type:"logo-buffer"}}),t._v(" 更好的递归")],1),t._v(" "),n("Divider"),t._v(" "),n("p",[t._v("因为在非严格模式下，我们在函数内部可以通过 arguments.callee 来访问正在执行的函数("),n("span",{staticClass:"text-info"},[t._v("arguments.callee 是一个指向正在执行的函数的指针")]),t._v(")，所以我们可以根据这一条来改进：")]),t._v(" "),n("pre",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"ml-2"},[n("code",{staticClass:"js"},[t._v("function factorial (num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * arguments.callee(num-1);\n    }\n} ")])]),t._v(" "),n("p",[t._v("但是在严格模式下，访问 arguments.callee 属性会导致错误，为了能够在严格模式和非严格模式下都能正常执行，我们需要用到的命名函数表达式：")]),t._v(" "),n("pre",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"ml-2"},[n("code",{staticClass:"js"},[t._v("var factorial = (function f (num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * f(num-1); }\n    }); ")])]),t._v(" "),n("p",[t._v("以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 factorial。即便把函数 赋值给了另一个变量，函数的名字f 仍然有效，所以递归调用照样能正确完成。")]),t._v(" "),n("p",{staticClass:"text-warn"},[t._v("需要注意的是：递归函数必须指定一个条件退出递归调用，否则会造成内存溢出。")]),t._v(" "),n("p",{staticClass:"text-right"},[t._v("参考资料：JavaScript 高级程序设计（第三版）")]),t._v(" "),n("FooterDivider")],1)])},e=[];i._withStripped=!0,n.d(a,"a",function(){return i}),n.d(a,"b",function(){return e})}}]);
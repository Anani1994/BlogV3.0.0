(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{346:function(t,e,a){"use strict";a.r(e);var i=a(492),n=a(384);for(var s in n)"default"!==s&&function(t){a.d(e,t,function(){return n[t]})}(s);var r=a(0),c=Object(r.a)(n.default,i.a,i.b,!1,null,null,null);c.options.__file="src/views/articles/frontend/javascript/RequireJS-3.vue",e.default=c.exports},384:function(t,e,a){"use strict";a.r(e);var i=a(385),n=a.n(i);for(var s in i)"default"!==s&&function(t){a.d(e,t,function(){return i[t]})}(s);e.default=n.a},385:function(t,e,a){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default={data:function(){return{toTop:this.$util.toTop}}}},492:function(t,e,a){"use strict";var i=function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("BoWen",[a("div",{staticClass:"p-1",attrs:{slot:"catalog"},slot:"catalog"},[a("Steps",{attrs:{direction:"vertical"}},[a("Step",{attrs:{title:"传统的 jsonp 服务",content:"传统的 jsonp 服务",status:"wait"},nativeOn:{click:function(e){t.toTop("#RequireJS-3-1",30)}}}),a("Step",{attrs:{title:"RequireJS 的 jsonp 服务",content:"RequireJS 的 jsonp 服务",status:"wait"},nativeOn:{click:function(e){t.toTop("#RequireJS-3-2",30)}}})],1)],1),a("div",{staticClass:"px-1"},[a("div",{staticClass:"py-3 text-center"},[a("h1",[a("Icon",{attrs:{type:"ios-book-outline"}}),t._v(" RequireJS (四)")],1),a("p",{staticClass:"pt-1"},[t._v("RequireJS 实现 jsonp 服务")])]),a("h3",{staticClass:"ml-1",attrs:{id:"RequireJS-3-1"}},[a("Icon",{attrs:{type:"logo-buffer"}}),t._v(" 传统的 jsonp 服务")],1),a("Divider"),a("p",[t._v("由于浏览器同源策略的影响，Ajax 请求不能跨域获取数据。")]),a("p",[t._v('所谓"同源"指的是"三个相同"：'),a("ul",{staticClass:"ml-1"},[a("li",[t._v("协议相同")]),a("li",[t._v("域名相同")]),a("li",[t._v("端口相同")])])]),a("p",[t._v("同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。如果非同源，共有三种行为受到限制："),a("ul",{staticClass:"ml-1"},[a("li",[t._v("Cookie、LocalStorage 和 IndexDB 无法读取。")]),a("li",[t._v("DOM 无法获得。")]),a("li",[t._v("AJAX 请求不能发送。")])])]),a("p",[t._v("那么 Ajax 请求如何规避这个限制呢？我们知道 JSONP 是服务器与客户端跨源通信的常用方法。它的基本思想是，网页通过添加一个 "),a("code",[t._v("<script> ")]),t._v("元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。")]),a("pre",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"ml-2"},[a("code",{staticClass:"js"},[t._v("/**\n * @param src 请求地址\n * @param callback 请求完成后执行的回调函数的函数名，这里设置为 loaded\n */\nfunction getDataByJsonp (src, callback) {\n    var url = src + '?callback=' + callback;\n    var script = document.createElement('script');\n    script.setAttribute(\"type\",\"text/javascript\");\n    script.src = url;\n    document.body.appendChild(script);\n}\n\n// 后台接收到请求后返回立即执行的函数，函数名为请求中所带参数指定的函数(callback)，本次实例即为 loaded\n// 并把需要获取的数据以参数的形式传入该函数\n// 后台返回的数据形式\nloaded({\n   id: 1,\n   userName: 'Anani',\n   age: 24\n})\n\n// 最后申明一个 callback 函数，这里即为 loaded 函数，它将会在请求成功后立即执行\nfunction loaded (arg) {\n    console.log(arg);\n}")])]),a("h3",{staticClass:"ml-1",attrs:{id:"RequireJS-3-2"}},[a("Icon",{attrs:{type:"logo-buffer"}}),t._v(" RequireJS 的 jsonp 服务")],1),a("Divider"),a("p",[t._v("前面介绍到 RequireJS 的运行机制是通过 script 标签来加载模块，所以我们也可以通过 RequireJS 来实现 jsonp 服务。")]),a("p",[t._v("在使用 RequireJS 实现 jsonp 服务时，我们需要把后台返回的数据写成 define() 函数的形式。")]),a("pre",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"ml-2"},[a("code",{staticClass:"js"},[t._v("// 后台的数据形式 \ndefine({\n    id: 1,\n    userName: 'Anani',\n    age: 24\n});\n \n// RequireJS 跨域获取数据\nrequire(['url'], function (arg) {\n    console.log(arg);\n});")])]),a("p",{staticClass:"text-right"},[t._v("还没有看过？点击 "),a("a",{staticClass:"forbidden",attrs:{href:"/#/articles/frontend/javascript/RequireJS-4"}},[t._v("RequireJS (五) ")]),t._v("查看更多内容。")]),a("p",{staticClass:"text-right"},[t._v("参考资料："),a("a",{staticClass:"mr-1",attrs:{href:"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html"}},[t._v("阮一峰的网络日志")]),a("a",{attrs:{href:"https://www.imooc.com/learn/787"}},[t._v("慕课网")])])],1)])},n=[];i._withStripped=!0,a.d(e,"a",function(){return i}),a.d(e,"b",function(){return n})}}]);